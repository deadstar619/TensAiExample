{
  "permissions": {
    "allow": [
      "Bash(find:)",
      "Bash(grep:*)",
      "Bash(head:*)",
      "Bash(find:*)",
      "Bash(node:*)",
      "Bash(where inkscape:*)",
      "Bash(tail:*)",
      "Bash(tr -cd '{}')",
      "Bash(python3:*)",
      "mcp__ide__getDiagnostics",
      "Bash(ls:*)",
      "Bash(cat:*)",
      "Bash(cat > \"/c/Unreal 5.7 Projects/TensAiExample/Plugins/TensAi/Source/TensAi/Private/BlueprintIR/TensAiIRValidator.cpp\" << 'CPPEOF'\n// TensAiIRValidator.cpp\n// Pre-flight validation of Blueprint IR before compilation.\n// Runs four phases: references, connections, conflicts, constraints.\n\n#if WITH_EDITOR\n\n#include \"BlueprintIR/TensAiIRValidator.h\"\n#include \"TensAiEditorLibraryInternal.h\"\n#include \"Engine/Blueprint.h\"\n#include \"Kismet2/BlueprintEditorUtils.h\"\n#include \"EdGraphSchema_K2.h\"\n\n// ── Levenshtein distance helper ────────────────────────────────\n\nnamespace\n{\n\t/**\n\t * Compute the Levenshtein \\(edit\\) distance between two strings.\n\t * Standard O\\(n*m\\) dynamic programming implementation.\n\t */\n\tint32 ComputeLevenshteinDistance\\(const FString& A, const FString& B\\)\n\t{\n\t\tconst int32 LenA = A.Len\\(\\);\n\t\tconst int32 LenB = B.Len\\(\\);\n\n\t\t// Fast-path: one or both strings empty\n\t\tif \\(LenA == 0\\) return LenB;\n\t\tif \\(LenB == 0\\) return LenA;\n\n\t\t// Allocate a \\(LenA+1\\) x \\(LenB+1\\) matrix using a flat array\n\t\tTArray<int32> Matrix;\n\t\tMatrix.SetNumUninitialized\\(\\(LenA + 1\\) * \\(LenB + 1\\)\\);\n\n\t\tauto At = [&]\\(int32 Row, int32 Col\\) -> int32&\n\t\t{\n\t\t\treturn Matrix[Row * \\(LenB + 1\\) + Col];\n\t\t};\n\n\t\t// Initialize first column and first row\n\t\tfor \\(int32 i = 0; i <= LenA; ++i\\)\n\t\t{\n\t\t\tAt\\(i, 0\\) = i;\n\t\t}\n\t\tfor \\(int32 j = 0; j <= LenB; ++j\\)\n\t\t{\n\t\t\tAt\\(0, j\\) = j;\n\t\t}\n\n\t\t// Fill the matrix\n\t\tfor \\(int32 i = 1; i <= LenA; ++i\\)\n\t\t{\n\t\t\tfor \\(int32 j = 1; j <= LenB; ++j\\)\n\t\t\t{\n\t\t\t\tconst int32 Cost = \\(FChar::ToLower\\(A[i - 1]\\) == FChar::ToLower\\(B[j - 1]\\)\\) ? 0 : 1;\n\t\t\t\tconst int32 Deletion = At\\(i - 1, j\\) + 1;\n\t\t\t\tconst int32 Insertion = At\\(i, j - 1\\) + 1;\n\t\t\t\tconst int32 Substitution = At\\(i - 1, j - 1\\) + Cost;\n\t\t\t\tAt\\(i, j\\) = FMath::Min3\\(Deletion, Insertion, Substitution\\);\n\t\t\t}\n\t\t}\n\n\t\treturn At\\(LenA, LenB\\);\n\t}\n\n\t/**\n\t * Common UE function names to suggest when a function reference fails to resolve.\n\t * This is a representative subset; the real resolution is handled by\n\t * TensAiInternal::FindFunctionByName, so we only need these for typo suggestions.\n\t */\n\tstatic const TArray<FString>& GetCommonFunctionNames\\(\\)\n\t{\n\t\tstatic const TArray<FString> Names = {\n\t\t\tTEXT\\(\"PrintString\"\\),\n\t\t\tTEXT\\(\"PrintText\"\\),\n\t\t\tTEXT\\(\"LaunchCharacter\"\\),\n\t\t\tTEXT\\(\"GetActorLocation\"\\),\n\t\t\tTEXT\\(\"SetActorLocation\"\\),\n\t\t\tTEXT\\(\"GetActorRotation\"\\),\n\t\t\tTEXT\\(\"SetActorRotation\"\\),\n\t\t\tTEXT\\(\"GetActorScale3D\"\\),\n\t\t\tTEXT\\(\"SetActorScale3D\"\\),\n\t\t\tTEXT\\(\"GetActorForwardVector\"\\),\n\t\t\tTEXT\\(\"GetActorUpVector\"\\),\n\t\t\tTEXT\\(\"GetActorRightVector\"\\),\n\t\t\tTEXT\\(\"AddActorWorldOffset\"\\),\n\t\t\tTEXT\\(\"AddActorWorldRotation\"\\),\n\t\t\tTEXT\\(\"AddActorLocalOffset\"\\),\n\t\t\tTEXT\\(\"AddActorLocalRotation\"\\),\n\t\t\tTEXT\\(\"GetVelocity\"\\),\n\t\t\tTEXT\\(\"GetComponentByClass\"\\),\n\t\t\tTEXT\\(\"GetComponentsByClass\"\\),\n\t\t\tTEXT\\(\"DestroyActor\"\\),\n\t\t\tTEXT\\(\"DestroyComponent\"\\),\n\t\t\tTEXT\\(\"SetActorHiddenInGame\"\\),\n\t\t\tTEXT\\(\"SetActorEnableCollision\"\\),\n\t\t\tTEXT\\(\"SetActorTickEnabled\"\\),\n\t\t\tTEXT\\(\"IsValid\"\\),\n\t\t\tTEXT\\(\"IsValidClass\"\\),\n\t\t\tTEXT\\(\"GetDisplayName\"\\),\n\t\t\tTEXT\\(\"GetClass\"\\),\n\t\t\tTEXT\\(\"GetName\"\\),\n\t\t\tTEXT\\(\"GetOwner\"\\),\n\t\t\tTEXT\\(\"GetInstigator\"\\),\n\t\t\tTEXT\\(\"GetWorld\"\\),\n\t\t\tTEXT\\(\"GetGameInstance\"\\),\n\t\t\tTEXT\\(\"GetPlayerController\"\\),\n\t\t\tTEXT\\(\"GetPlayerCharacter\"\\),\n\t\t\tTEXT\\(\"GetPlayerCameraManager\"\\),\n\t\t\tTEXT\\(\"GetPlayerPawn\"\\),\n\t\t\tTEXT\\(\"SpawnActor\"\\),\n\t\t\tTEXT\\(\"BeginSpawningActorFromClass\"\\),\n\t\t\tTEXT\\(\"FinishSpawningActor\"\\),\n\t\t\tTEXT\\(\"SetLifeSpan\"\\),\n\t\t\tTEXT\\(\"GetLifeSpan\"\\),\n\t\t\tTEXT\\(\"SetTimerByEvent\"\\),\n\t\t\tTEXT\\(\"SetTimerByFunctionName\"\\),\n\t\t\tTEXT\\(\"ClearTimer\"\\),\n\t\t\tTEXT\\(\"ClearAndInvalidateTimerByHandle\"\\),\n\t\t\tTEXT\\(\"Delay\"\\),\n\t\t\tTEXT\\(\"RetriggerableDelay\"\\),\n\t\t\tTEXT\\(\"MoveComponentTo\"\\),\n\t\t\tTEXT\\(\"SetWorldLocation\"\\),\n\t\t\tTEXT\\(\"SetWorldRotation\"\\),\n\t\t\tTEXT\\(\"SetRelativeLocation\"\\),\n\t\t\tTEXT\\(\"SetRelativeRotation\"\\),\n\t\t\tTEXT\\(\"SetWorldScale3D\"\\),\n\t\t\tTEXT\\(\"SetVisibility\"\\),\n\t\t\tTEXT\\(\"ToggleVisibility\"\\),\n\t\t\tTEXT\\(\"SetCollisionEnabled\"\\),\n\t\t\tTEXT\\(\"SetCollisionProfileName\"\\),\n\t\t\tTEXT\\(\"SetSimulatePhysics\"\\),\n\t\t\tTEXT\\(\"AddImpulse\"\\),\n\t\t\tTEXT\\(\"AddForce\"\\),\n\t\t\tTEXT\\(\"AddTorqueInRadians\"\\),\n\t\t\tTEXT\\(\"SetPhysicsLinearVelocity\"\\),\n\t\t\tTEXT\\(\"SetPhysicsAngularVelocityInDegrees\"\\),\n\t\t\tTEXT\\(\"LineTraceByChannel\"\\),\n\t\t\tTEXT\\(\"SphereTraceByChannel\"\\),\n\t\t\tTEXT\\(\"BoxTraceByChannel\"\\),\n\t\t\tTEXT\\(\"LineTraceByProfile\"\\),\n\t\t\tTEXT\\(\"BreakHitResult\"\\),\n\t\t\tTEXT\\(\"MakeHitResult\"\\),\n\t\t\tTEXT\\(\"PlaySound2D\"\\),\n\t\t\tTEXT\\(\"PlaySoundAtLocation\"\\),\n\t\t\tTEXT\\(\"SpawnSoundAtLocation\"\\),\n\t\t\tTEXT\\(\"SpawnEmitterAtLocation\"\\),\n\t\t\tTEXT\\(\"SpawnEmitterAttached\"\\),\n\t\t\tTEXT\\(\"SpawnSystemAtLocation\"\\),\n\t\t\tTEXT\\(\"SpawnSystemAttached\"\\),\n\t\t\tTEXT\\(\"SetMaterial\"\\),\n\t\t\tTEXT\\(\"SetStaticMesh\"\\),\n\t\t\tTEXT\\(\"SetSkeletalMesh\"\\),\n\t\t\tTEXT\\(\"CreateDynamicMaterialInstance\"\\),\n\t\t\tTEXT\\(\"SetScalarParameterValue\"\\),\n\t\t\tTEXT\\(\"SetVectorParameterValue\"\\),\n\t\t\tTEXT\\(\"SetTextureParameterValue\"\\),\n\t\t\tTEXT\\(\"PlayAnimMontage\"\\),\n\t\t\tTEXT\\(\"StopAnimMontage\"\\),\n\t\t\tTEXT\\(\"GetCurrentMontage\"\\),\n\t\t\tTEXT\\(\"Jump\"\\),\n\t\t\tTEXT\\(\"StopJumping\"\\),\n\t\t\tTEXT\\(\"Crouch\"\\),\n\t\t\tTEXT\\(\"UnCrouch\"\\),\n\t\t\tTEXT\\(\"AddMovementInput\"\\),\n\t\t\tTEXT\\(\"GetCharacterMovement\"\\),\n\t\t\tTEXT\\(\"GetCapsuleComponent\"\\),\n\t\t\tTEXT\\(\"GetMesh\"\\),\n\t\t\tTEXT\\(\"SetMaxWalkSpeed\"\\),\n\t\t\tTEXT\\(\"MakeVector\"\\),\n\t\t\tTEXT\\(\"BreakVector\"\\),\n\t\t\tTEXT\\(\"MakeRotator\"\\),\n\t\t\tTEXT\\(\"BreakRotator\"\\),\n\t\t\tTEXT\\(\"MakeTransform\"\\),\n\t\t\tTEXT\\(\"BreakTransform\"\\),\n\t\t\tTEXT\\(\"MakeColor\"\\),\n\t\t\tTEXT\\(\"BreakColor\"\\),\n\t\t\tTEXT\\(\"VectorLength\"\\),\n\t\t\tTEXT\\(\"Normalize\"\\),\n\t\t\tTEXT\\(\"DotProduct\"\\),\n\t\t\tTEXT\\(\"CrossProduct\"\\),\n\t\t\tTEXT\\(\"Lerp\"\\),\n\t\t\tTEXT\\(\"FInterpTo\"\\),\n\t\t\tTEXT\\(\"RInterpTo\"\\),\n\t\t\tTEXT\\(\"VInterpTo\"\\),\n\t\t\tTEXT\\(\"GetWorldDeltaSeconds\"\\),\n\t\t\tTEXT\\(\"GetTimeSeconds\"\\),\n\t\t\tTEXT\\(\"RandomFloatInRange\"\\),\n\t\t\tTEXT\\(\"RandomIntegerInRange\"\\),\n\t\t\tTEXT\\(\"Clamp\"\\),\n\t\t\tTEXT\\(\"MapRangeClamped\"\\),\n\t\t\tTEXT\\(\"MapRangeUnclamped\"\\),\n\t\t\tTEXT\\(\"GetActorOfClass\"\\),\n\t\t\tTEXT\\(\"GetAllActorsOfClass\"\\),\n\t\t\tTEXT\\(\"GetAllActorsWithTag\"\\),\n\t\t\tTEXT\\(\"GetAllActorsWithInterface\"\\),\n\t\t\tTEXT\\(\"GetOverlappingActors\"\\),\n\t\t\tTEXT\\(\"GetOverlappingComponents\"\\),\n\t\t\tTEXT\\(\"OnComponentBeginOverlap\"\\),\n\t\t\tTEXT\\(\"OnComponentEndOverlap\"\\),\n\t\t\tTEXT\\(\"SetText\"\\),\n\t\t\tTEXT\\(\"SetColorAndOpacity\"\\),\n\t\t\tTEXT\\(\"AddToViewport\"\\),\n\t\t\tTEXT\\(\"RemoveFromParent\"\\),\n\t\t\tTEXT\\(\"CreateWidget\"\\),\n\t\t\tTEXT\\(\"OpenLevel\"\\),\n\t\t\tTEXT\\(\"GetCurrentLevelName\"\\),\n\t\t\tTEXT\\(\"QuitGame\"\\),\n\t\t};\n\t\treturn Names;\n\t}\n\n\t/**\n\t * Find function names within a given edit distance of the input string.\n\t * Returns suggestions sorted by ascending edit distance.\n\t */\n\tTArray<FString> FindSimilarFunctionNames\\(const FString& Input, int32 MaxDistance = 3\\)\n\t{\n\t\tstruct FSuggestion\n\t\t{\n\t\t\tFString Name;\n\t\t\tint32 Distance;\n\t\t};\n\n\t\tTArray<FSuggestion> Candidates;\n\n\t\tfor \\(const FString& FuncName : GetCommonFunctionNames\\(\\)\\)\n\t\t{\n\t\t\t// Quick length check to skip obviously different names\n\t\t\tif \\(FMath::Abs\\(FuncName.Len\\(\\) - Input.Len\\(\\)\\) > MaxDistance\\)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst int32 Dist = ComputeLevenshteinDistance\\(Input, FuncName\\);\n\t\t\tif \\(Dist > 0 && Dist <= MaxDistance\\)\n\t\t\t{\n\t\t\t\tCandidates.Add\\({ FuncName, Dist }\\);\n\t\t\t}\n\t\t}\n\n\t\t// Sort by distance ascending\n\t\tCandidates.Sort\\([]\\(const FSuggestion& A, const FSuggestion& B\\)\n\t\t{\n\t\t\treturn A.Distance < B.Distance;\n\t\t}\\);\n\n\t\tTArray<FString> Results;\n\t\tResults.Reserve\\(Candidates.Num\\(\\)\\);\n\t\tfor \\(const FSuggestion& S : Candidates\\)\n\t\t{\n\t\t\tResults.Add\\(S.Name\\);\n\t\t}\n\t\treturn Results;\n\t}\n\n\t/**\n\t * Collect all node IDs from the event graph and all function graphs.\n\t */\n\tvoid CollectAllNodeIds\\(const FTensAiBlueprintIR& IR, TSet<FString>& OutNodeIds\\)\n\t{\n\t\tfor \\(const FTensAiIRNode& Node : IR.EventGraphNodes\\)\n\t\t{\n\t\t\tOutNodeIds.Add\\(Node.Id\\);\n\t\t}\n\t\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t\t{\n\t\t\tfor \\(const FTensAiIRNode& Node : Func.Nodes\\)\n\t\t\t{\n\t\t\t\tOutNodeIds.Add\\(Node.Id\\);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Count total nodes across event graph and all functions.\n\t */\n\tint32 CountTotalNodes\\(const FTensAiBlueprintIR& IR\\)\n\t{\n\t\tint32 Count = IR.EventGraphNodes.Num\\(\\);\n\t\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t\t{\n\t\t\tCount += Func.Nodes.Num\\(\\);\n\t\t}\n\t\treturn Count;\n\t}\n\n\t/**\n\t * Check if a node type represents an entry point \\(event or custom event\\).\n\t */\n\tbool IsEntryPointNode\\(const FString& NodeType\\)\n\t{\n\t\treturn NodeType == TEXT\\(\"event\"\\) || NodeType == TEXT\\(\"custom_event\"\\);\n\t}\n}\n\n// ── Validate \\(entry point\\) ─────────────────────────────────────\n\nFTensAiValidationResult FTensAiIRValidator::Validate\\(\n\tconst FTensAiBlueprintIR& IR,\n\tUBlueprint* ExistingBlueprint\\)\n{\n\tFTensAiValidationResult Result;\n\n\t// Phase 1: Reference resolution\n\tValidateReferences\\(IR, Result\\);\n\n\t// Phase 2: Connection validity\n\tValidateConnections\\(IR.EventGraphNodes, IR.EventGraphConnections, TEXT\\(\"EventGraph\"\\), Result\\);\n\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t{\n\t\tValidateConnections\\(Func.Nodes, Func.Connections, Func.Name, Result\\);\n\t}\n\n\t// Phase 3: Conflict detection \\(only if modifying an existing blueprint\\)\n\tValidateConflicts\\(IR, ExistingBlueprint, Result\\);\n\n\t// Phase 4: Constraint checks\n\tValidateConstraints\\(IR, Result\\);\n\n\treturn Result;\n}\n\n// ── Phase 1: ValidateReferences ────────────────────────────────\n\nvoid FTensAiIRValidator::ValidateReferences\\(\n\tconst FTensAiBlueprintIR& IR,\n\tFTensAiValidationResult& Result\\)\n{\n\tconst FString Phase = TEXT\\(\"reference\"\\);\n\n\t// Check BlueprintPath is not empty\n\tif \\(IR.BlueprintPath.IsEmpty\\(\\)\\)\n\t{\n\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\), TEXT\\(\"BlueprintPath is empty. A valid asset path is required.\"\\)\\);\n\t}\n\n\t// Check ParentClass resolves\n\tif \\(IR.ParentClass.IsEmpty\\(\\)\\)\n\t{\n\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\), TEXT\\(\"ParentClass is empty. A valid parent class is required \\(e.g., \\\\\"Actor\\\\\", \\\\\"Character\\\\\"\\).\"\\)\\);\n\t}\n\telse\n\t{\n\t\tUClass* ParentClass = TensAiInternal::FindClassByName\\(IR.ParentClass\\);\n\t\tif \\(!ParentClass\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tFString::Printf\\(TEXT\\(\"ParentClass \\\\\"%s\\\\\" could not be resolved to a valid UClass.\"\\), *IR.ParentClass\\)\\);\n\t\t}\n\t}\n\n\t// Check variable types resolve\n\tfor \\(const FTensAiIRVariable& Var : IR.Variables\\)\n\t{\n\t\tif \\(Var.Type.IsEmpty\\(\\)\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tFString::Printf\\(TEXT\\(\"Variable \\\\\"%s\\\\\" has an empty type.\"\\), *Var.Name\\)\\);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFEdGraphPinType ResolvedType = TensAiInternal::ResolvePinType\\(Var.Type\\);\n\n\t\t// If ResolvePinType returns float for a non-float/double input, it fell through to default\n\t\tconst bool bIsFloatResult = \\(ResolvedType.PinCategory == UEdGraphSchema_K2::PC_Real ||\n\t\t                             ResolvedType.PinCategory == UEdGraphSchema_K2::PC_Float ||\n\t\t                             ResolvedType.PinCategory == UEdGraphSchema_K2::PC_Double\\);\n\t\tconst FString TypeLower = Var.Type.ToLower\\(\\);\n\t\tconst bool bIsFloatInput = \\(TypeLower == TEXT\\(\"float\"\\) || TypeLower == TEXT\\(\"double\"\\) || TypeLower == TEXT\\(\"real\"\\)\\);\n\n\t\tif \\(bIsFloatResult && !bIsFloatInput\\)\n\t\t{\n\t\t\tResult.AddWarning\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tFString::Printf\\(TEXT\\(\"Variable \\\\\"%s\\\\\": type \\\\\"%s\\\\\" resolved to float \\(default fallback\\). This may not be the intended type.\"\\),\n\t\t\t\t\t*Var.Name, *Var.Type\\)\\);\n\t\t}\n\t}\n\n\t// Helper lambda: validate a single node's type-specific references\n\tauto ValidateNodeReferences = [&]\\(const FTensAiIRNode& Node\\)\n\t{\n\t\tif \\(Node.Type == TEXT\\(\"call\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.Function.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"Call node has an empty function name.\"\\)\\);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUFunction* Func = TensAiInternal::FindFunctionByName\\(Node.Function\\);\n\t\t\t\tif \\(!Func\\)\n\t\t\t\t{\n\t\t\t\t\tTArray<FString> Suggestions = FindSimilarFunctionNames\\(Node.Function\\);\n\t\t\t\t\tFString Message = FString::Printf\\(\n\t\t\t\t\t\tTEXT\\(\"Function \\\\\"%s\\\\\" could not be resolved.\"\\), *Node.Function\\);\n\n\t\t\t\t\tif \\(Suggestions.Num\\(\\) > 0\\)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessage += TEXT\\(\" Did you mean: \"\\);\n\t\t\t\t\t\tfor \\(int32 i = 0; i < Suggestions.Num\\(\\) && i < 3; ++i\\)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif \\(i > 0\\) Message += TEXT\\(\", \"\\);\n\t\t\t\t\t\t\tMessage += FString::Printf\\(TEXT\\(\"\\\\\"%s\\\\\"\"\\), *Suggestions[i]\\);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMessage += TEXT\\(\"?\"\\);\n\t\t\t\t\t}\n\n\t\t\t\t\tResult.AddError\\(Phase, Node.Id, Message, Suggestions\\);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"cast\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.TargetClass.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"Cast node has an empty TargetClass.\"\\)\\);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUClass* CastClass = TensAiInternal::FindClassByName\\(Node.TargetClass\\);\n\t\t\t\tif \\(!CastClass\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Node.Id,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"Cast target class \\\\\"%s\\\\\" could not be resolved.\"\\), *Node.TargetClass\\)\\);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"var_get\"\\) || Node.Type == TEXT\\(\"var_set\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.Variable.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id,\n\t\t\t\t\tFString::Printf\\(TEXT\\(\"%s node has an empty variable name.\"\\), *Node.Type\\)\\);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check that the variable exists in the IR's Variables array\n\t\t\t\tbool bFound = false;\n\t\t\t\tfor \\(const FTensAiIRVariable& Var : IR.Variables\\)\n\t\t\t\t{\n\t\t\t\t\tif \\(Var.Name == Node.Variable\\)\n\t\t\t\t\t{\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif \\(!bFound\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Node.Id,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"%s node references variable \\\\\"%s\\\\\" which is not declared in the IR Variables array.\"\\),\n\t\t\t\t\t\t\t*Node.Type, *Node.Variable\\)\\);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"event\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.Event.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"Event node has an empty event name.\"\\)\\);\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"custom_event\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.CustomEventName.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"Custom event node has an empty custom event name.\"\\)\\);\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"macro\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.MacroName.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"Macro node has an empty macro name.\"\\)\\);\n\t\t\t}\n\t\t}\n\t\telse if \\(Node.Type == TEXT\\(\"switch_enum\"\\)\\)\n\t\t{\n\t\t\tif \\(Node.EnumPath.IsEmpty\\(\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddError\\(Phase, Node.Id, TEXT\\(\"switch_enum node has an empty EnumPath.\"\\)\\);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tUEnum* EnumObj = FindObject<UEnum>\\(nullptr, *Node.EnumPath\\);\n\t\t\t\tif \\(!EnumObj\\)\n\t\t\t\t{\n\t\t\t\t\t// Try with /Script/Engine prefix\n\t\t\t\t\tFString AltPath = FString::Printf\\(TEXT\\(\"/Script/Engine.%s\"\\), *Node.EnumPath\\);\n\t\t\t\t\tEnumObj = FindObject<UEnum>\\(nullptr, *AltPath\\);\n\t\t\t\t}\n\t\t\t\tif \\(!EnumObj\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Node.Id,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"switch_enum EnumPath \\\\\"%s\\\\\" could not be resolved to a valid UEnum.\"\\), *Node.EnumPath\\)\\);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Validate all event graph nodes\n\tfor \\(const FTensAiIRNode& Node : IR.EventGraphNodes\\)\n\t{\n\t\tValidateNodeReferences\\(Node\\);\n\t}\n\n\t// Validate all function graph nodes\n\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t{\n\t\tfor \\(const FTensAiIRNode& Node : Func.Nodes\\)\n\t\t{\n\t\t\tValidateNodeReferences\\(Node\\);\n\t\t}\n\t}\n}\n\n// ── Phase 2: ValidateConnections ───────────────────────────────\n\nvoid FTensAiIRValidator::ValidateConnections\\(\n\tconst TArray<FTensAiIRNode>& Nodes,\n\tconst TArray<FTensAiIRConnection>& Connections,\n\tconst FString& GraphScope,\n\tFTensAiValidationResult& Result\\)\n{\n\tconst FString Phase = TEXT\\(\"connection\"\\);\n\n\t// Build a set of valid node IDs for this graph scope\n\tTSet<FString> ValidNodeIds;\n\tValidNodeIds.Reserve\\(Nodes.Num\\(\\)\\);\n\tfor \\(const FTensAiIRNode& Node : Nodes\\)\n\t{\n\t\tValidNodeIds.Add\\(Node.Id\\);\n\t}\n\n\tfor \\(int32 ConnIdx = 0; ConnIdx < Connections.Num\\(\\); ++ConnIdx\\)\n\t{\n\t\tconst FTensAiIRConnection& Conn = Connections[ConnIdx];\n\t\tconst FString ConnLabel = FString::Printf\\(TEXT\\(\"[%s] connection %d \\(%s -> %s\\)\"\\),\n\t\t\t*GraphScope, ConnIdx, *Conn.FromNode, *Conn.ToNode\\);\n\n\t\t// Verify FromNode exists\n\t\tif \\(Conn.FromNode.IsEmpty\\(\\)\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tFString::Printf\\(TEXT\\(\"%s: FromNode is empty.\"\\), *ConnLabel\\)\\);\n\t\t}\n\t\telse if \\(!ValidNodeIds.Contains\\(Conn.FromNode\\)\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, Conn.FromNode,\n\t\t\t\tFString::Printf\\(TEXT\\(\"%s: FromNode \\\\\"%s\\\\\" does not exist in graph scope \\\\\"%s\\\\\".\"\\),\n\t\t\t\t\t*ConnLabel, *Conn.FromNode, *GraphScope\\)\\);\n\t\t}\n\n\t\t// Verify ToNode exists\n\t\tif \\(Conn.ToNode.IsEmpty\\(\\)\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tFString::Printf\\(TEXT\\(\"%s: ToNode is empty.\"\\), *ConnLabel\\)\\);\n\t\t}\n\t\telse if \\(!ValidNodeIds.Contains\\(Conn.ToNode\\)\\)\n\t\t{\n\t\t\tResult.AddError\\(Phase, Conn.ToNode,\n\t\t\t\tFString::Printf\\(TEXT\\(\"%s: ToNode \\\\\"%s\\\\\" does not exist in graph scope \\\\\"%s\\\\\".\"\\),\n\t\t\t\t\t*ConnLabel, *Conn.ToNode, *GraphScope\\)\\);\n\t\t}\n\n\t\t// Warn on self-connections \\(rare but possible\\)\n\t\tif \\(!Conn.FromNode.IsEmpty\\(\\) && Conn.FromNode == Conn.ToNode\\)\n\t\t{\n\t\t\tResult.AddWarning\\(Phase, Conn.FromNode,\n\t\t\t\tFString::Printf\\(TEXT\\(\"%s: Self-connection detected \\(FromNode == ToNode == \\\\\"%s\\\\\"\\). This is unusual.\"\\),\n\t\t\t\t\t*ConnLabel, *Conn.FromNode\\)\\);\n\t\t}\n\t}\n}\n\n// ── Phase 3: ValidateConflicts ─────────────────────────────────\n\nvoid FTensAiIRValidator::ValidateConflicts\\(\n\tconst FTensAiBlueprintIR& IR,\n\tUBlueprint* ExistingBlueprint,\n\tFTensAiValidationResult& Result\\)\n{\n\tif \\(!ExistingBlueprint\\)\n\t{\n\t\treturn;\n\t}\n\n\tconst FString Phase = TEXT\\(\"conflict\"\\);\n\n\t// Collect event names from the IR\n\tTSet<FString> IREventNames;\n\tfor \\(const FTensAiIRNode& Node : IR.EventGraphNodes\\)\n\t{\n\t\tif \\(Node.Type == TEXT\\(\"event\"\\) && !Node.Event.IsEmpty\\(\\)\\)\n\t\t{\n\t\t\tIREventNames.Add\\(Node.Event\\);\n\t\t}\n\t}\n\n\tif \\(IREventNames.Num\\(\\) == 0\\)\n\t{\n\t\treturn;\n\t}\n\n\t// Check the existing blueprint's event graph for duplicate event nodes\n\tUEdGraph* EventGraph = TensAiInternal::GetBlueprintEventGraph\\(ExistingBlueprint\\);\n\tif \\(!EventGraph\\)\n\t{\n\t\treturn;\n\t}\n\n\tfor \\(UEdGraphNode* ExistingNode : EventGraph->Nodes\\)\n\t{\n\t\tif \\(!ExistingNode\\)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if this is a K2 event node by looking at its class name and title\n\t\t// Event nodes in K2 graphs are UK2Node_Event instances\n\t\tconst FString NodeTitle = ExistingNode->GetNodeTitle\\(ENodeTitleType::FullTitle\\).ToString\\(\\);\n\n\t\tfor \\(const FString& IREvent : IREventNames\\)\n\t\t{\n\t\t\t// Match by checking if the existing node title contains the event name\n\t\t\t// Common patterns: \"Event BeginPlay\", \"Event ActorBeginOverlap\", etc.\n\t\t\tconst FString EventPrefix = FString::Printf\\(TEXT\\(\"Event %s\"\\), *IREvent\\);\n\t\t\tif \\(NodeTitle.Contains\\(IREvent\\) || NodeTitle.Contains\\(EventPrefix\\)\\)\n\t\t\t{\n\t\t\t\tResult.AddWarning\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\t\tFString::Printf\\(TEXT\\(\"Event \\\\\"%s\\\\\" already exists in the existing blueprint's event graph. \"\n\t\t\t\t\t\t\"The IR also declares this event, which may cause a duplicate.\"\\), *IREvent\\)\\);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ── Phase 4: ValidateConstraints ───────────────────────────────\n\nvoid FTensAiIRValidator::ValidateConstraints\\(\n\tconst FTensAiBlueprintIR& IR,\n\tFTensAiValidationResult& Result\\)\n{\n\tconst FString Phase = TEXT\\(\"constraint\"\\);\n\n\t// Check total node count\n\tconst int32 TotalNodes = CountTotalNodes\\(IR\\);\n\tconstexpr int32 WarnThreshold = 200;\n\tconstexpr int32 ErrorThreshold = 500;\n\n\tif \\(TotalNodes > ErrorThreshold\\)\n\t{\n\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\tFString::Printf\\(TEXT\\(\"Total node count \\(%d\\) exceeds the maximum of %d. \"\n\t\t\t\t\"Consider splitting into multiple blueprints or simplifying the graph.\"\\),\n\t\t\t\tTotalNodes, ErrorThreshold\\)\\);\n\t}\n\telse if \\(TotalNodes > WarnThreshold\\)\n\t{\n\t\tResult.AddWarning\\(Phase, TEXT\\(\"\"\\),\n\t\t\tFString::Printf\\(TEXT\\(\"Total node count \\(%d\\) exceeds %d. \"\n\t\t\t\t\"Large blueprints can impact editor performance and maintainability.\"\\),\n\t\t\t\tTotalNodes, WarnThreshold\\)\\);\n\t}\n\n\t// Check all node IDs are unique across the entire IR\n\t{\n\t\tTMap<FString, FString> NodeIdToScope; // NodeId -> first scope where it appeared\n\n\t\tauto CheckUniqueIds = [&]\\(const TArray<FTensAiIRNode>& Nodes, const FString& ScopeName\\)\n\t\t{\n\t\t\tfor \\(const FTensAiIRNode& Node : Nodes\\)\n\t\t\t{\n\t\t\t\tif \\(Node.Id.IsEmpty\\(\\)\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"A node in scope \\\\\"%s\\\\\" has an empty ID.\"\\), *ScopeName\\)\\);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif \\(const FString* ExistingScope = NodeIdToScope.Find\\(Node.Id\\)\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Node.Id,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"Duplicate node ID \\\\\"%s\\\\\" found in scope \\\\\"%s\\\\\" \"\n\t\t\t\t\t\t\t\"\\(previously seen in scope \\\\\"%s\\\\\"\\). All node IDs must be unique.\"\\),\n\t\t\t\t\t\t\t*Node.Id, *ScopeName, **ExistingScope\\)\\);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNodeIdToScope.Add\\(Node.Id, ScopeName\\);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tCheckUniqueIds\\(IR.EventGraphNodes, TEXT\\(\"EventGraph\"\\)\\);\n\t\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t\t{\n\t\t\tCheckUniqueIds\\(Func.Nodes, FString::Printf\\(TEXT\\(\"Function:%s\"\\), *Func.Name\\)\\);\n\t\t}\n\t}\n\n\t// Check that the event graph has at least one entry point\n\t{\n\t\tbool bHasEntryPoint = false;\n\t\tfor \\(const FTensAiIRNode& Node : IR.EventGraphNodes\\)\n\t\t{\n\t\t\tif \\(IsEntryPointNode\\(Node.Type\\)\\)\n\t\t\t{\n\t\t\t\tbHasEntryPoint = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif \\(!bHasEntryPoint && IR.EventGraphNodes.Num\\(\\) > 0\\)\n\t\t{\n\t\t\tResult.AddWarning\\(Phase, TEXT\\(\"\"\\),\n\t\t\t\tTEXT\\(\"The event graph has nodes but no entry points \\(event or custom_event\\). \"\n\t\t\t\t\t\"Without an entry point, event graph logic will never execute.\"\\)\\);\n\t\t}\n\t}\n\n\t// Check that connections don't reference node IDs outside their graph scope\n\t{\n\t\tauto ValidateConnectionScope = [&]\\(\n\t\t\tconst TArray<FTensAiIRNode>& Nodes,\n\t\t\tconst TArray<FTensAiIRConnection>& Connections,\n\t\t\tconst FString& ScopeName\\)\n\t\t{\n\t\t\tTSet<FString> ScopeNodeIds;\n\t\t\tScopeNodeIds.Reserve\\(Nodes.Num\\(\\)\\);\n\t\t\tfor \\(const FTensAiIRNode& Node : Nodes\\)\n\t\t\t{\n\t\t\t\tif \\(!Node.Id.IsEmpty\\(\\)\\)\n\t\t\t\t{\n\t\t\t\t\tScopeNodeIds.Add\\(Node.Id\\);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor \\(int32 i = 0; i < Connections.Num\\(\\); ++i\\)\n\t\t\t{\n\t\t\t\tconst FTensAiIRConnection& Conn = Connections[i];\n\n\t\t\t\tif \\(!Conn.FromNode.IsEmpty\\(\\) && !ScopeNodeIds.Contains\\(Conn.FromNode\\)\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Conn.FromNode,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"[%s] Connection %d references FromNode \\\\\"%s\\\\\" which is not in this graph scope.\"\\),\n\t\t\t\t\t\t\t*ScopeName, i, *Conn.FromNode\\)\\);\n\t\t\t\t}\n\t\t\t\tif \\(!Conn.ToNode.IsEmpty\\(\\) && !ScopeNodeIds.Contains\\(Conn.ToNode\\)\\)\n\t\t\t\t{\n\t\t\t\t\tResult.AddError\\(Phase, Conn.ToNode,\n\t\t\t\t\t\tFString::Printf\\(TEXT\\(\"[%s] Connection %d references ToNode \\\\\"%s\\\\\" which is not in this graph scope.\"\\),\n\t\t\t\t\t\t\t*ScopeName, i, *Conn.ToNode\\)\\);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tValidateConnectionScope\\(IR.EventGraphNodes, IR.EventGraphConnections, TEXT\\(\"EventGraph\"\\)\\);\n\t\tfor \\(const FTensAiIRFunction& Func : IR.Functions\\)\n\t\t{\n\t\t\tValidateConnectionScope\\(Func.Nodes, Func.Connections, FString::Printf\\(TEXT\\(\"Function:%s\"\\), *Func.Name\\)\\);\n\t\t}\n\t}\n}\n\n#endif // WITH_EDITOR\nCPPEOF)",
      "Bash(printf print\\(\"hello\"\\)\\\\nprint\\(chr\\(39\\)\\)\\\\nprint\\(\"world\"\\):*)",
      "Bash(wc:*)",
      "Bash(python3 $TMPPY:*)",
      "Bash(\"C:/Program Files/Epic Games/UE_5.7/Engine/Build/BatchFiles/Build.bat\" TensAiExampleEditor:*)",
      "mcp__tensai__search_classes",
      "mcp__tensai__read_engine_source",
      "mcp__tensai__search_functions",
      "WebSearch",
      "WebFetch(domain:modelcontextprotocol.github.io)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "WebFetch(domain:gofastmcp.com)",
      "WebFetch(domain:dev.to)",
      "WebFetch(domain:pypi.org)",
      "WebFetch(domain:www.aubergine.co)",
      "Bash(python:*)",
      "Bash(pip install:*)",
      "mcp__tensai__get_editor_context",
      "mcp__tensai__query_knowledge_base",
      "mcp__tensai__get_python_api_help",
      "mcp__tensai__execute_python",
      "Bash(tasklist:*)",
      "Bash(claude mcp:*)",
      "Bash(curl:*)",
      "Bash(pip show:*)",
      "Bash(where python:*)",
      "mcp__tensai__editor_status",
      "Bash(\"/c/Program Files/Epic Games/UE_5.7/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.exe\" TensAiExampleEditor:*)",
      "Bash(which mcp__tensai__list_blueprint_assets:*)",
      "mcp__tensai__call_tool",
      "mcp__tensai__close_editor",
      "mcp__tensai__build_project",
      "Bash(\"/c/Program Files/Epic Games/UE_5.7/Engine/Binaries/Win64/UnrealEditor.exe\":*)",
      "WebFetch(domain:www.npmjs.com)",
      "Bash(echo:*)",
      "WebFetch(domain:www.aihero.dev)",
      "WebFetch(domain:mcpcat.io)",
      "WebFetch(domain:www.speakeasy.com)",
      "WebFetch(domain:mcpui.dev)",
      "WebFetch(domain:unpkg.com)",
      "Bash(cd \"/c/Unreal 5.7 Projects/TensAiExample/Plugins/TensAi/Tools/mcp-bridge\" && npm install 2>&1)",
      "mcp__tensai__inspect_node_template",
      "mcp__tensai__compile_blueprint_ir",
      "mcp__tensai__live_coding",
      "Bash(powershell:*)",
      "mcp__tensai__take_viewport_screenshot",
      "Bash(taskkill:*)",
      "mcp__tensai__get_build_diagnostics"
    ]
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "tensai"
  ]
}
